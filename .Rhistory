with_expo <- with_expo %>% dplyr::select(all_of(common_cols))
data_surv <-rbind(without_expo, with_expo)
#===============================================================================
#   PIVOT WIDE for WEEKS_SINCE_COVID
#-------------------------------------------------------------------------------
#data_surv$days_to_expo <- as.numeric(data_surv$expo_date - as.Date(cohort_start_date))
interval_names <- mapply(function(x, y) ifelse(x == y, paste0("days", x), paste0("days", x, "_", y)),
lag(cuts_days_since_expo, default = 0),
cuts_days_since_expo,
SIMPLIFY = FALSE)
intervals <- mapply(c, lag(cuts_days_since_expo, default = 0), cuts_days_since_expo, SIMPLIFY = F)
i<-0
for (ls in mapply(list, interval_names, intervals, SIMPLIFY = F)){
i <- i+1
data_surv[[ls[[1]]]] <- if_else(data_surv$days_cat==i, 1, 0)
}
#===============================================================================
# FINALIZE age, region, data_surv
#-------------------------------------------------------------------------------
data_surv <- data_surv %>% left_join(df_age_region_ethnicity)
data_surv <- data_surv %>% left_join(df_sex)
print(paste0("Finished survival data"))
# ============================= EVENTS COUNT =================================
which_days_since_covid <- function(row_data_surv, interval_names){
days_cols <- row_data_surv %>% dplyr::select(all_of(interval_names))
expo_day_period <- names(days_cols)[which(days_cols == 1)]
row_data_surv$expo_days <- ifelse(length(expo_day_period)==0, NA,expo_day_period )
#row_data_surv$expo_days <- names(days_cols)[which(days_cols == 1)]
row_data_surv$expo_days <- ifelse(is.na(row_data_surv$expo_days),"pre expo", row_data_surv$expo_days)
return(row_data_surv)
}
get_tbl_event_count <- function(data_surv, interval_names){
df_events <- data_surv %>% filter(event==1)
ls_data_surv <- split(df_events, 1:nrow(df_events))
ls_data_surv <- lapply(ls_data_surv, which_days_since_covid, unlist(interval_names))
ls_data_surv <- do.call("rbind", ls_data_surv)
tbl_event_count <- aggregate(event ~ expo_days, ls_data_surv, sum)
tbl_event_count[nrow(tbl_event_count) + 1,] = c("all post expo", sum(head(tbl_event_count$event, (nrow(tbl_event_count)-1)))  )
return(tbl_event_count)
}
tbl_event_count_all <- get_tbl_event_count(data_surv, interval_names)
tbl_event_count <- list(tbl_event_count_all) %>% reduce(left_join, by = "expo_days")
event_count_levels <- c("pre expo", unlist(interval_names), "all post expo")
tbl_event_count_levels <- data.frame(event_count_levels)
names(tbl_event_count_levels) <- c("expo_days")
tbl_event_count <- merge(tbl_event_count_levels, tbl_event_count, all.x = TRUE)
tbl_event_count[is.na(tbl_event_count)] <- 0
tbl_event_count <- tbl_event_count %>%
arrange(factor(expo_days,
levels = event_count_levels),
expo_days)
names(tbl_event_count) <- c("expo_week", "events_total")
tbl_event_count$event=event
tbl_event_count$subgroup <- subgroup
tbl_event_count$model <- mdl
tbl_event_count$events_total <- as.numeric(tbl_event_count$events_total)
#Any time periods with <=5 events? If yes, will reduce time periods
ind_any_zeroeventperiod <- any((tbl_event_count$events_total <= 5) & (!identical(cuts_days_since_expo, c(28, 535))))
#Are there <50 post expo events? If yes, won't run analysis
less_than_50_events = any((as.numeric(tbl_event_count$events_total) < 50) & (tbl_event_count$expo_week=="all post expo"))
# If ind_any_zeroeventperiod==TRUE then this script will re-run again with reduced time periods and
# we only want to save the final event count file. For reduced time periods, ind_any_zeroeventperiod will
# always be FALSE
# Save events counts if less than 50 events as this script will not re-run with reduced time periods
if(ind_any_zeroeventperiod==FALSE | less_than_50_events==TRUE){
write.csv(tbl_event_count, paste0(output_dir,"/tbl_event_count_" ,event,"_", subgroup,"_",mdl,".csv"), row.names = T)
print(paste0("Event counts saved: ", output_dir,"/tbl_event_count_" ,event,"_", subgroup,"_",mdl,".csv"))
}
return(list(data_surv, noncase_ids, interval_names, ind_any_zeroeventperiod, non_case_inverse_weight, less_than_50_events))
}else{
analyses_not_run[nrow(analyses_not_run)+1,]<- c(event,subgroup,mdl,any_exposures,any_exposed_events,any_no_expo,"FALSE")
return(list(analyses_not_run))
}
}
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/descriptives/venn_diagram.R", echo=TRUE)
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/descriptives/venn_diagram.R", echo=TRUE)
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/descriptives/venn_diagram.R", echo=TRUE)
## =============================================================================
## Purpose:  Create venn diagrams
##
## Author:   Yinghui Wei
##
## Reviewer: Renin Toms, Venexia Walker
##
## Date:     6 December 2021; updated 10 January 2022; updated 27 January 2022
##
## Data:     Post covid vaccinated project study population
##
## Content:  to create a Venn diagram for each outcome outlining overlap in
##           reporting from different data sources
## Output:   Venn diagrams in SVG files, venn_diagram_number_check.csv
## =============================================================================
library(data.table)
library(readr)
library(dplyr)
args <- commandArgs(trailingOnly=TRUE)
if(length(args)==0){
# use for interactive testing
cohort_name <- "vaccinated"
} else {
cohort_name <- args[[1]]
}
fs::dir_create(here::here("output", "not-for-review"))
fs::dir_create(here::here("output", "review", "venn-diagrams"))
venn_output <- function(cohort_name){
# Identify active outcomes ---------------------------------------------------
active_analyses <- readr::read_rds("lib/active_analyses.rds")
outcomes <- active_analyses[active_analyses$active==TRUE,]$outcome_variable
# Load data ------------------------------------------------------------------
input <- readr::read_rds(paste0("output/venn_",cohort_name,".rds"))
end_dates <- read_rds(paste0("output/follow_up_end_dates_",cohort_name,".rds"))
input_stage1 <- readr::read_rds(paste0("output/input_", cohort_name,"_stage1.rds"))
input_stage1 <- input_stage1[input_stage1$sub_bin_covid19_confirmed_history==FALSE,]
input <- input[input$patient_id %in% input_stage1$patient_id,]
input<- input %>% left_join(end_dates, by="patient_id")
rm(input_stage1,end_dates)
# Create empty table ---------------------------------------------------------
df <- data.frame(outcome = character(),
only_snomed = numeric(),
only_hes = numeric(),
only_death = numeric(),
snomed_hes = numeric(),
snomed_death = numeric(),
hes_death = numeric(),
snomed_hes_death = numeric(),
total_snomed = numeric(),
total_hes = numeric(),
total_death = numeric(),
total = numeric(),
stringsAsFactors = FALSE)
# Populate table and make Venn for each outcome ------------------------------
for (outcome in outcomes) {
outcome_save_name <- outcome
print(paste0("Working on ", outcome))
# Restrict data to that relevant to the given outcome ----------------------
if(grepl("_primary_position",outcome)==TRUE){
tmp <- input[!is.na(input[,outcome]),c("patient_id","index_date",paste0(gsub("out_date_","", outcome),"_follow_up_end"),outcome, colnames(input)[grepl(paste0("tmp_",gsub("_primary_position","", outcome)),colnames(input))])]
tmp[,grepl(paste0("tmp_",gsub("_primary_position","", outcome),"_hes"),colnames(tmp))] <- NULL
colnames(tmp) <- gsub("_primary_position","",colnames(tmp))
}else{
tmp <- input[!is.na(input[,outcome]),c("patient_id","index_date",paste0(gsub("out_date_","", outcome),"_follow_up_end"), colnames(input)[grepl(outcome,colnames(input))])]
tmp[,grepl("_primary_position",colnames(tmp))] <- NULL
}
outcome <- gsub("_primary_position","",outcome)
colnames(tmp) <- gsub(paste0("tmp_",outcome,"_"),"",colnames(tmp))
setnames(tmp,
old=c(paste0(gsub("out_date_","", outcome),"_follow_up_end"),
outcome),
new=c("follow_up_end",
"event_date"))
tmp <- tmp %>% filter(follow_up_end >= index_date)
# Impose follow-up start and end dates on events dates
event_cols <- c("snomed","hes","death","event_date")
for(colname in event_cols){
if(colname %in% colnames(tmp)){
tmp <- tmp %>% mutate(!!sym(colname) := replace(!!sym(colname), which(!!sym(colname)>follow_up_end | !!sym(colname)<index_date), NA))
}
}
# Identify and add missing columns -----------------------------------------
complete <- data.frame(patient_id = tmp$patient_id,
snomed = as.Date(NA),
hes = as.Date(NA),
death = as.Date(NA))
#colnames(complete) <- c("patient_id",paste0("tmp_",outcome,c("_snomed","_hes","_death")))
complete[,setdiff(colnames(tmp),"patient_id")] <- NULL
notused <- NULL
if (ncol(complete)>1) {
tmp <- merge(tmp, complete, by = c("patient_id"))
notused <- setdiff(colnames(complete),"patient_id")
}
# Calculate the number contributing to each source combo -------------------
tmp$snomed_contributing <- !is.na(tmp$snomed) &
is.na(tmp$hes) &
is.na(tmp$death)
tmp$hes_contributing <- is.na(tmp$snomed) &
!is.na(tmp$hes) &
is.na(tmp$death)
tmp$death_contributing <- is.na(tmp$snomed) &
is.na(tmp$hes) &
!is.na(tmp$death)
tmp$snomed_hes_contributing <- !is.na(tmp$snomed) &
!is.na(tmp$hes) &
is.na(tmp$death)
tmp$hes_death_contributing <- is.na(tmp$snomed) &
!is.na(tmp$hes) &
!is.na(tmp$death)
tmp$snomed_death_contributing <- !is.na(tmp$snomed) &
is.na(tmp$hes) &
!is.na(tmp$death)
tmp$snomed_hes_death_contributing <- !is.na(tmp$snomed) &
!is.na(tmp$hes) &
!is.na(tmp$death)
df[nrow(df)+1,] <- c(outcome_save_name,
only_snomed = nrow(tmp %>% filter(snomed_contributing==T)),
only_hes = nrow(tmp %>% filter(hes_contributing==T)),
only_death = nrow(tmp %>% filter(death_contributing==T)),
snomed_hes = nrow(tmp %>% filter(snomed_hes_contributing==T)),
snomed_death = nrow(tmp %>% filter(snomed_death_contributing==T)),
hes_death = nrow(tmp %>% filter(hes_death_contributing==T)),
snomed_hes_death = nrow(tmp %>% filter(snomed_hes_death_contributing==T)),
total_snomed = nrow(tmp %>% filter(!is.na(snomed))),
total_hes = nrow(tmp %>% filter(!is.na(hes))),
total_death = nrow(tmp %>% filter(!is.na(death))),
total = nrow(tmp %>% filter(!is.na(event_date))))
# Remove sources not in study definition from Venn plots and summary -------
source_combos <- c("only_snomed","only_hes","only_death","snomed_hes","snomed_death","hes_death","snomed_hes_death")
source_consid <- source_combos
if (!is.null(notused)) {
for (i in notused) {
# Add variables to consider for Venn plot to vector
source_consid <- source_combos[!grepl(i,source_combos)]
# Replace unused sources with NA in summary table
for (j in setdiff(source_combos,source_consid)) {
df[df$outcome==outcome,j] <- NA
}
}
}
# Proceed to create Venn diagram if all source combos exceed 5 -------------
#if (min(as.numeric(df[df$outcome==outcome,source_consid]))>5) {
# Calculate contents of each Venn cell for plotting ----------------------
index1 <- integer(0)
index2 <- integer(0)
index3 <- integer(0)
if ("only_snomed" %in% source_consid) {
index1 <- which(!is.na(tmp$snomed))
}
if ("only_hes" %in% source_consid) {
index2 <- which(!is.na(tmp$hes))
}
if ("only_death" %in% source_consid) {
index3 <- which(!is.na(tmp$death))
}
index <- list(index1, index2, index3)
names(index) <- c("Primary care", "Secondary care", "Death record")
index <- Filter(length, index)
# Fix colours --------------------------------------------------------------
mycol <- c(ifelse("Primary care" %in% names(index),"thistle",""),
ifelse("Secondary care" %in% names(index),"lightcyan",""),
ifelse("Death record" %in% names(index),"lemonchiffon",""))
mycol <- mycol[mycol!=""]
# Make Venn diagram --------------------------------------------------------
svglite::svglite(file = paste0("output/review/venn-diagrams/venn_diagram_",cohort_name,"_",gsub("out_date_","",outcome_save_name),".svg"))
g <- ggvenn::ggvenn(
index,
fill_color = mycol,
stroke_color = "white",
text_size = 5,
set_name_size = 5,
fill_alpha = 0.9
) +  ggplot2::ggtitle(active_analyses[active_analyses$outcome_variable==outcome_save_name,]$outcome) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 15, face = "bold"))
print(g)
dev.off()
}
#}
# Save summary file ----------------------------------------------------------
# Merge any cells <= 5 to the highest cell (excluding totals) -------------
colnamesorder <- colnames(df)
a <- df[-c(1,9:12)]
a[] <- sapply(a, as.numeric)
idx <- cbind(seq(nrow(a)), max.col(a))
a[idx] <- a[idx] + rowSums(a * (a <= 5))
is.na(a) <- a <= 5
df <- cbind(df[c(1,9:12)], a)
df <- setcolorder(df, colnamesorder)
# remove totals column as these are calculated in external_venn_script.R
df <- select(df, -contains("total"))
#change NAs to 0
df[is.na(df)] <- 0
write.csv(df, file = paste0("output/review/venn-diagrams/venn_diagram_number_check_", cohort_name,".csv"), row.names = F)
}
# Run function using specified commandArgs -------------------------------------
if(cohort_name == "both"){
venn_output("electively_unvaccinated")
venn_output("vaccinated")
} else{
venn_output(cohort_name)
}
## Reviewer: Renin Toms, Venexia Walker
##
## Date:     6 December 2021; updated 10 January 2022; updated 27 January 2022
##
## Data:     Post covid vaccinated project study population
##
## Content:  to create a Venn diagram for each outcome outlining overlap in
##           reporting from different data sources
## Output:   Venn diagrams in SVG files, venn_diagram_number_check.csv
## =============================================================================
library(data.table)
library(readr)
library(dplyr)
args <- commandArgs(trailingOnly=TRUE)
if(length(args)==0){
# use for interactive testing
cohort_name <- "vaccinated"
} else {
cohort_name <- args[[1]]
}
fs::dir_create(here::here("output", "not-for-review"))
fs::dir_create(here::here("output", "review", "venn-diagrams"))
venn_output <- function(cohort_name){
# Identify active outcomes ---------------------------------------------------
active_analyses <- readr::read_rds("lib/active_analyses.rds")
outcomes <- active_analyses[active_analyses$active==TRUE,]$outcome_variable
# Load data ------------------------------------------------------------------
input <- readr::read_rds(paste0("output/venn_",cohort_name,".rds"))
end_dates <- read_rds(paste0("output/follow_up_end_dates_",cohort_name,".rds"))
input_stage1 <- readr::read_rds(paste0("output/input_", cohort_name,"_stage1.rds"))
input_stage1 <- input_stage1[input_stage1$sub_bin_covid19_confirmed_history==FALSE,]
input <- input[input$patient_id %in% input_stage1$patient_id,]
input<- input %>% left_join(end_dates, by="patient_id")
rm(input_stage1,end_dates)
# Create empty table ---------------------------------------------------------
df <- data.frame(outcome = character(),
only_snomed = numeric(),
only_hes = numeric(),
only_death = numeric(),
snomed_hes = numeric(),
snomed_death = numeric(),
hes_death = numeric(),
snomed_hes_death = numeric(),
total_snomed = numeric(),
total_hes = numeric(),
total_death = numeric(),
total = numeric(),
stringsAsFactors = FALSE)
# Populate table and make Venn for each outcome ------------------------------
for (outcome in outcomes) {
outcome_save_name <- outcome
print(paste0("Working on ", outcome))
# Restrict data to that relevant to the given outcome ----------------------
if(grepl("_primary_position",outcome)==TRUE){
tmp <- input[!is.na(input[,outcome]),c("patient_id","index_date",paste0(gsub("out_date_","", outcome),"_follow_up_end"),outcome, colnames(input)[grepl(paste0("tmp_",gsub("_primary_position","", outcome)),colnames(input))])]
tmp[,grepl(paste0("tmp_",gsub("_primary_position","", outcome),"_hes"),colnames(tmp))] <- NULL
colnames(tmp) <- gsub("_primary_position","",colnames(tmp))
}else{
tmp <- input[!is.na(input[,outcome]),c("patient_id","index_date",paste0(gsub("out_date_","", outcome),"_follow_up_end"), colnames(input)[grepl(outcome,colnames(input))])]
tmp[,grepl("_primary_position",colnames(tmp))] <- NULL
}
outcome <- gsub("_primary_position","",outcome)
colnames(tmp) <- gsub(paste0("tmp_",outcome,"_"),"",colnames(tmp))
setnames(tmp,
old=c(paste0(gsub("out_date_","", outcome),"_follow_up_end"),
outcome),
new=c("follow_up_end",
"event_date"))
tmp <- tmp %>% filter(follow_up_end >= index_date)
# Impose follow-up start and end dates on events dates
event_cols <- c("snomed","hes","death","event_date")
for(colname in event_cols){
if(colname %in% colnames(tmp)){
tmp <- tmp %>% mutate(!!sym(colname) := replace(!!sym(colname), which(!!sym(colname)>follow_up_end | !!sym(colname)<index_date), NA))
}
}
# Identify and add missing columns -----------------------------------------
complete <- data.frame(patient_id = tmp$patient_id,
snomed = as.Date(NA),
hes = as.Date(NA),
death = as.Date(NA))
#colnames(complete) <- c("patient_id",paste0("tmp_",outcome,c("_snomed","_hes","_death")))
complete[,setdiff(colnames(tmp),"patient_id")] <- NULL
notused <- NULL
if (ncol(complete)>1) {
tmp <- merge(tmp, complete, by = c("patient_id"))
notused <- setdiff(colnames(complete),"patient_id")
}
# Calculate the number contributing to each source combo -------------------
tmp$snomed_contributing <- !is.na(tmp$snomed) &
is.na(tmp$hes) &
is.na(tmp$death)
tmp$hes_contributing <- is.na(tmp$snomed) &
!is.na(tmp$hes) &
is.na(tmp$death)
tmp$death_contributing <- is.na(tmp$snomed) &
is.na(tmp$hes) &
!is.na(tmp$death)
tmp$snomed_hes_contributing <- !is.na(tmp$snomed) &
!is.na(tmp$hes) &
is.na(tmp$death)
tmp$hes_death_contributing <- is.na(tmp$snomed) &
!is.na(tmp$hes) &
!is.na(tmp$death)
tmp$snomed_death_contributing <- !is.na(tmp$snomed) &
is.na(tmp$hes) &
!is.na(tmp$death)
tmp$snomed_hes_death_contributing <- !is.na(tmp$snomed) &
!is.na(tmp$hes) &
!is.na(tmp$death)
df[nrow(df)+1,] <- c(outcome_save_name,
only_snomed = nrow(tmp %>% filter(snomed_contributing==T)),
only_hes = nrow(tmp %>% filter(hes_contributing==T)),
only_death = nrow(tmp %>% filter(death_contributing==T)),
snomed_hes = nrow(tmp %>% filter(snomed_hes_contributing==T)),
snomed_death = nrow(tmp %>% filter(snomed_death_contributing==T)),
hes_death = nrow(tmp %>% filter(hes_death_contributing==T)),
snomed_hes_death = nrow(tmp %>% filter(snomed_hes_death_contributing==T)),
total_snomed = nrow(tmp %>% filter(!is.na(snomed))),
total_hes = nrow(tmp %>% filter(!is.na(hes))),
total_death = nrow(tmp %>% filter(!is.na(death))),
total = nrow(tmp %>% filter(!is.na(event_date))))
# Remove sources not in study definition from Venn plots and summary -------
source_combos <- c("only_snomed","only_hes","only_death","snomed_hes","snomed_death","hes_death","snomed_hes_death")
source_consid <- source_combos
if (!is.null(notused)) {
for (i in notused) {
# Add variables to consider for Venn plot to vector
source_consid <- source_combos[!grepl(i,source_combos)]
# Replace unused sources with NA in summary table
for (j in setdiff(source_combos,source_consid)) {
df[df$outcome==outcome,j] <- NA
}
}
}
# Proceed to create Venn diagram if all source combos exceed 5 -------------
#if (min(as.numeric(df[df$outcome==outcome,source_consid]))>5) {
# Calculate contents of each Venn cell for plotting ----------------------
index1 <- integer(0)
index2 <- integer(0)
index3 <- integer(0)
if ("only_snomed" %in% source_consid) {
index1 <- which(!is.na(tmp$snomed))
}
if ("only_hes" %in% source_consid) {
index2 <- which(!is.na(tmp$hes))
}
if ("only_death" %in% source_consid) {
index3 <- which(!is.na(tmp$death))
}
index <- list(index1, index2, index3)
names(index) <- c("Primary care", "Secondary care", "Death record")
index <- Filter(length, index)
# Fix colours --------------------------------------------------------------
mycol <- c(ifelse("Primary care" %in% names(index),"thistle",""),
ifelse("Secondary care" %in% names(index),"lightcyan",""),
ifelse("Death record" %in% names(index),"lemonchiffon",""))
mycol <- mycol[mycol!=""]
# Make Venn diagram --------------------------------------------------------
svglite::svglite(file = paste0("output/review/venn-diagrams/venn_diagram_",cohort_name,"_",gsub("out_date_","",outcome_save_name),".svg"))
g <- ggvenn::ggvenn(
index,
fill_color = mycol,
stroke_color = "white",
text_size = 5,
set_name_size = 5,
fill_alpha = 0.9
) +  ggplot2::ggtitle(active_analyses[active_analyses$outcome_variable==outcome_save_name,]$outcome) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 15, face = "bold"))
print(g)
dev.off()
}
#}
# Save summary file ----------------------------------------------------------
# Merge any cells <= 5 to the highest cell (excluding totals) -------------
colnamesorder <- colnames(df)
a <- df[-c(1,9:12)]
a[] <- sapply(a, as.numeric)
idx <- cbind(seq(nrow(a)), max.col(a))
a[idx] <- a[idx] + rowSums(a * (a <= 5))
is.na(a) <- a <= 5
df <- cbind(df[c(1,9:12)], a)
df <- setcolorder(df, colnamesorder)
# remove totals column as these are calculated in external_venn_script.R
df <- select(df, -contains("total"))
#change NAs to 0
df[is.na(df)] <- 0
write.csv(df, file = paste0("output/review/venn-diagrams/venn_diagram_number_check_", cohort_name,".csv"), row.names = F)
}
if(cohort_name == "both"){
venn_output("electively_unvaccinated")
venn_output("vaccinated")
} else{
venn_output(cohort_name)
}
cohort_name
active_analyses <- readr::read_rds("lib/active_analyses.rds")
outcomes <- active_analyses[active_analyses$active==TRUE,]$outcome_variable
input <- readr::read_rds(paste0("output/venn_",cohort_name,".rds"))
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/descriptives/venn_diagram.R", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/create_project_actions.R", echo=TRUE)
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/create_project_actions.R", echo=TRUE)
source("C:/Users/yingh_/OneDrive - University of Plymouth/Research/Research Projects/01 COVID/covid-projects/post-covid-unvaccinated/analysis/descriptives/external_venn.R", echo=TRUE)
df <- read.csv("output/review/venn-diagrams/venn_diagram_number_check_diabetes.csv")
df
active_analyses <- readr::read_rds("lib/active_analyses.rds")
# list of outcomes to loop over
outcomes <- df$outcome
outcomes
df <- read.csv("output/review/venn-diagrams/venn_diagram_number_check_diabetes.csv")
# calculate totals columns
df <- df %>%
mutate(total_snomed = rowSums(select(., contains('snomed'))),
total_hes = rowSums(select(., contains('hes'))),
total_death = rowSums(select(., contains('death')))) %>%
mutate(total = rowSums(select(., contains('total'))))
df <- subset(df, outcome == i)
cols.num <- c("only_snomed", "only_hes", "only_death", "snomed_hes", "snomed_death", "hes_death","snomed_hes_death", "total_snomed",
"total_hes","total_death","total" )
df[cols.num] <- sapply(df[cols.num],as.numeric)
# create Venn diagram with three sets
svglite::svglite(file = paste0("output/review/venn-diagrams/venn_diagram_NEWTEST_",gsub("out_date_","",i),".svg"))
grid.newpage()
g <- draw.triple.venn(area1=df$total_snomed, area2=df$total_hes, area3=df$total_death,
n12=df$snomed_hes, n23=df$hes_death, n13=df$snomed_death, n123=df$snomed_hes_death,
category=c("Primary care","Secondary care","Death records"),
col="white",fill=c("thistle","lightcyan","lemonchiffon"),
print.mode = c("raw", "percent"),
sigdigs = 3)
g <- grid.arrange(gTree(children=g), top=textGrob(active_analyses[active_analyses$outcome_variable==i,]$outcome, gp = gpar(fontsize = 18, fontface="bold")))
print(g)
g
